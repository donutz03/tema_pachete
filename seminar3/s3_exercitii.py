import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv("StoresPrep.csv")

# Display the first five rows of the dataset
print(df.head(5))

"""
This dataset contains information about different stores, including various features associated with each store.

Here's a breakdown of the columns:
Store_Number: A numerical identifier for each store.
AreaStore: The area of the store.
Property: Indicates whether the property is owned, rented, or a cooperation.
Type: Describes the type of store (e.g., Hyper, Extra, Express).
Old/New: Indicates whether the store is old or new.
Checkout Number: The number of checkout counters in the store.
Revenue: The revenue generated by the store.

"""

# Display basic information about the dataset
print(len(df), ' e numarul de randuri')
print(len(df.columns), ' e numarul de coloane')

print('tipul de date al fiecarei coloane este\n')
print(df.dtypes)


# Display descriptive statistics
print('statistici descriptive despre coloanele cu valori non-numerice')
print(df.describe())


# Check for missing values
print('numarul de date lipsa al fiecarei coloane\n')
print(df.isna().sum())

# Display number of unique values in Property column
print('numarul de valori unice al coloanei "Property" este:')
print(df['Property'].nunique())


# Display number of unique values in each column
print('numarul de valori unice al fiecarei coloane')
for column in df.columns:
    print(column, ' ', df[column].nunique())


# Display unique values in each column
for column in df.columns:
    print(column, ' ', df[column].unique())


'''
Selecting Rows
Using loc: Select the rows where Store_Number is 3.
Using iloc: Select the row at the third position (keep in mind Python is 0-indexed).
'''
randuri = df.loc[df['Store_Number']==3]
print(randuri, '\nnumarul de randuri care au store number egal cu 3 ', len(randuri))

rand = df.iloc[2]
print('randul 3 este\n', rand)

'''
Selecting Columns
Using loc: Select the Revenue column for all rows.
Using iloc: Select the last column for all rows.
'''
# Using loc to select Revenue column for all rows
revenue_col = df.loc[:, 'Revenue']
print("\nRevenue column for all rows using loc:")
print(revenue_col.head())

# Using iloc to select the last column for all rows
last_col = df.iloc[:, -1]
print("\nLast column for all rows using iloc:")
print(last_col.head())

'''
Selecting Rows and Columns
Using loc: Select Store_Number and Revenue columns for stores 1 and 4.
Using iloc: Select the first and last columns for the first and fourth rows.
'''
# Using loc to select Store_Number and Revenue columns for stores 1 and 4
selected_stores = df.loc[df['Store_Number'].isin([1, 4]), ['Store_Number', 'Revenue']]
print("\nStore_Number and Revenue for stores 1 and 4 using loc:")
print(selected_stores)

# Using iloc to select the first and last columns for the first and fourth rows
first_last_cols = df.iloc[[0, 3], [0, -1]]  # Rows 0 and 3, columns 0 and -1
print("\nFirst and last columns for first and fourth rows using iloc:")
print(first_last_cols)

'''
Conditional Selection
Using loc: Select all rows where the Type is 'Hyper'.
Using iloc: iloc does not directly support conditional selection based on column values.
'''
# Using loc to select all rows where Type is 'Hyper'
hyper_stores = df.loc[df['Type'] == 'Hyper']
print("\nStores with Type 'Hyper' using loc:")
print(hyper_stores)

# Alternative approach for conditional selection with iloc (first find indices)
hyper_indices = df.index[df['Type'] == 'Hyper'].tolist()
hyper_stores_iloc = df.iloc[hyper_indices]
print("\nStores with Type 'Hyper' using iloc (indirect):")
print(hyper_stores_iloc)

'''
Updating a Value
Using loc: Change the Type of store 2 to 'Super'.
'''
# First, make a copy of the dataframe to avoid modifying the original
df_copy = df.copy()

# Update the Type of store 2 to 'Super' using loc
df_copy.loc[df_copy['Store_Number'] == 2, 'Type'] = 'Super'
print("\nAfter updating Type of store 2 to 'Super':")
print(df_copy[df_copy['Store_Number'] == 2])

'''
Slicing Rows
Using loc: Selected rows 1 through 3 (inclusive of both ends).
Using iloc: Selected the first three rows.
'''
# Using loc to select rows 1 through 3 (inclusive)
# Assuming there's an index column that starts from 1, otherwise we need to use row indices
rows_1_to_3_loc = df.loc[1:3]  # This will select rows with index 1, 2, and 3
print("\nRows 1 through 3 using loc:")
print(rows_1_to_3_loc)

# Using iloc to select the first three rows
first_three_rows = df.iloc[0:3]  # This will select rows at positions 0, 1, and 2
print("\nFirst three rows using iloc:")
print(first_three_rows)

'''Calculate the total Revenue across all stores.'''
total_revenue = df['Revenue'].sum()
print(f"\nTotal Revenue across all stores: {total_revenue}")

'''Calculate the average AreaStore size.'''
avg_area = df['AreaStore'].mean()
print(f"\nAverage AreaStore size: {avg_area}")

'''Find the maximum Checkout Number across all stores. '''
max_checkout = df['Checkout Number'].max()
print(f"\nMaximum Checkout Number: {max_checkout}")

'''Identify the store with the smallest AreaStore.'''
smallest_area_store = df.loc[df['AreaStore'].idxmin()]
print("\nStore with the smallest AreaStore:")
print(smallest_area_store)


'''------------------Group BY ----------------------------'''

'''
The groupby operation in pandas is used for aggregating data, allowing you to group your data by one or more 
columns and then perform calculations or transformations on those groups.
This operation is similar to the SQL GROUP BY statement and is extremely useful for data analysis, 
allowing you to break down complex datasets into more manageable pieces or to perform calculations on subsets
of your data based on certain criteria.

How It Works
The groupby operation can be broken down into three steps:

Splitting: The data is divided into groups based on one or more keys. This is done on a specific axis of the DataFrame or Series, 
typically rows (axis=0).
Applying: A function is applied to each group independently. This function could be an aggregation (returning a single value per group), 
a transformation (returning a version of the data), or a filtration (returning a subset of the data).
Combining: The results of the function applications are combined into a new DataFrame or Series.


Syntax
The basic syntax of a groupby operation in pandas is:
df.groupby(by=None, axis=0, level=None, as_index=True, sort=True, group_keys=True, squeeze=NoDefault.no_default, observed=False, dropna=True)


by ->  can be a single column, a list of columns, or even mappings (like dictionaries or series) that define the grouping.
axis  -> specifies the axis to group on. By default, it's set to 0, which means the operation is performed on rows.
as_index ->is a boolean indicating whether to group by the index (default is True).
'''

'''Calculate the total revenue for each Type of store. '''
revenue_by_type = df.groupby('Type')['Revenue'].sum()
print("\nTotal revenue for each Type of store:")
print(revenue_by_type)

'''Find the average Checkout Number for each Old/New category.'''
avg_checkout_by_category = df.groupby('Old/New')['Checkout Number'].mean()
print("\nAverage Checkout Number for each Old/New category:")
print(avg_checkout_by_category)


'''----------------------'Aggregation'---------------------------'''
'''
The agg function in pandas is used for performing aggregation operations on DataFrame or Series objects.
It allows you to apply one or more operations across a specified axis of the DataFrame or Series, 
making it highly versatile for data summarization tasks. '''

'''Find the total, average, and maximum revenue for each Type of store.'''
revenue_stats_by_type = df.groupby('Type')['Revenue'].agg(['sum', 'mean', 'max'])
print("\nRevenue statistics for each Type of store:")
print(revenue_stats_by_type)

'''Identify the store with the highest revenue for each Type.'''
'''-involves two steps: first, using groupby and idxmax to find the index of the row with
the highest revenue for each store type, 
and second, using loc to retrieve the complete information for these rows.'''

# First, find the index of the max revenue per Type
max_revenue_indices = df.groupby('Type')['Revenue'].idxmax()

# Then, use loc to get the rows corresponding to these indices
highest_revenue_stores = df.loc[max_revenue_indices]
print("\nStore with the highest revenue for each Type:")
print(highest_revenue_stores)

'''For each Type of store, find the revenue of the store with the highest AreaStore, and its respective Store_Number.'''

# Group by 'Type' and then apply a custom function to each group
def get_store_with_highest_area(group):
    max_area_idx = group['AreaStore'].idxmax()
    return pd.Series({
        'Store_Number': group.loc[max_area_idx, 'Store_Number'],
        'Revenue': group.loc[max_area_idx, 'Revenue'],
        'AreaStore': group.loc[max_area_idx, 'AreaStore']
    })

largest_stores_by_type = df.groupby('Type').apply(get_store_with_highest_area)
print("\nRevenue and Store_Number of store with highest AreaStore for each Type:")
print(largest_stores_by_type)


'''_______________Graphics_________________'''

# Plot the distribution of Revenue
plt.figure(figsize=(10, 6))
plt.hist(df['Revenue'], bins=20, color='blue', edgecolor='black')
plt.title('Distribution of Revenue')
plt.xlabel('Revenue')
plt.ylabel('Frequency')
plt.show()

# Pie chart to visualize the distribution of Property types
plt.figure(figsize=(8, 8))
property_counts = df['Property'].value_counts()
plt.pie(property_counts, labels=property_counts.index, autopct='%1.1f%%', startangle=90)
plt.title("Distribution of Property Types")
plt.show()

'''Bar Plot of Average Revenue by Store Type'''
# Step 1: Group by 'Type' and calculate mean revenue
average_revenue_by_type = df.groupby('Type')['Revenue'].mean()

# Step 2: Plot directly from the DataFrame
plt.figure(figsize=(10, 6))
average_revenue_by_type.plot(kind='bar', color='skyblue', edgecolor='black')
plt.title('Average Revenue by Store Type')
plt.xlabel('Store Type')
plt.ylabel('Average Revenue')
plt.xticks(rotation=45)
plt.show()

# Additional data visualization - Scatter plot of AreaStore vs Revenue
plt.figure(figsize=(10, 6))
plt.scatter(df['AreaStore'], df['Revenue'], alpha=0.7, c=df['Store_Number'], cmap='viridis')
plt.colorbar(label='Store Number')
plt.title('Relationship between Store Area and Revenue')
plt.xlabel('Store Area')
plt.ylabel('Revenue')
plt.grid(True, linestyle='--', alpha=0.7)
plt.show()

# Box plot of Revenue by Type
plt.figure(figsize=(12, 6))
df.boxplot(column='Revenue', by='Type', grid=False)
plt.title('Revenue Distribution by Store Type')
plt.ylabel('Revenue')
plt.xticks(rotation=45)
plt.suptitle('')  # Remove the default suptitle
plt.show()

# Line plot showing the relationship between Store_Number and Checkout Number
plt.figure(figsize=(12, 6))
df.sort_values('Store_Number').plot(x='Store_Number', y='Checkout Number', kind='line', marker='o')
plt.title('Checkout Numbers by Store')
plt.xlabel('Store Number')
plt.ylabel('Number of Checkouts')
plt.grid(True, linestyle='--', alpha=0.7)
plt.show()